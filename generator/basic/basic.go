package basic

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"sort"

	"github.com/gen0cide/ecsgen"
	"github.com/gen0cide/ecsgen/generator"
	"github.com/urfave/cli"
)

var (
	// ErrInvalidPackageName is thrown when a Go package name is either not specified or is not valid.
	ErrInvalidPackageName = errors.New("package name was either empty or an invalid go package identifier")

	// ErrInvalidOutputDir is thrown when the output directory does not exist.
	ErrInvalidOutputDir = errors.New("output directory was either blank or did not exist")
)

type basic struct {
	PackageName string
	OutputDir   string
	Pointers    bool
}

// New is a constructor for an empty debug output plugin.
func New() generator.Generator {
	return &basic{}
}

// ID implements the generator.Generator interface.
// Package: github.com/gen0cide/ecsgen/generator
func (b *basic) ID() string {
	return "go_basic"
}

// CLIFlags implements the generator.Generator interface.
// Package: github.com/gen0cide/ecsgen/generator
func (b *basic) CLIFlags() []cli.Flag {
	return []cli.Flag{
		&cli.StringFlag{
			Name:        "package-name",
			Usage:       "Name of the Go package for the generated code.",
			EnvVars:     []string{"PACKAGE_NAME"},
			Destination: &b.PackageName,
		},
		&cli.StringFlag{
			Name:        "output-dir",
			Usage:       "Path to the directory where the generated code should be written.",
			EnvVars:     []string{"OUTPUT_DIR"},
			Destination: &b.OutputDir,
		},
		&cli.BoolFlag{
			Name:        "use-pointers",
			Usage:       "Force the generator to use pointer types as best as possible.",
			EnvVars:     []string{"USE_POINTERS"},
			Destination: &b.Pointers,
		},
	}
}

// Validate implements the generator.Generator interface.
// Package: github.com/gen0cide/ecsgen/generator
func (b *basic) Validate() error {
	// Check the Output Directory
	// is it assigned?
	if b.OutputDir == "" {
		return ErrInvalidOutputDir
	}

	// Is it a valid path?
	dir, err := os.Stat(b.OutputDir)
	if err != nil {
		if os.IsNotExist(err) {
			return ErrInvalidOutputDir
		}

		return fmt.Errorf("error locating specified output directory: %v", err)
	}

	// is it a valid directory?
	if !dir.IsDir() {
		return fmt.Errorf("specified output directory was a path to a file, not a directory")
	}

	// while Go maintains STRONG guidance on package naming conventions,
	// it doesn't actually seem to enforce a whole lot. Keeping it basic for now.
	pkgRegex := regexp.MustCompile(`^[a-zA-Z0-9\_]{1,64}$`)
	if !pkgRegex.MatchString(b.PackageName) {
		return ErrInvalidPackageName
	}

	return nil
}

// Execute implements the generator.Generator interface.
// Package: github.com/gen0cide/ecsgen/generator
func (b *basic) Execute(root *ecsgen.Root) error {
	keys := []string{}

	// enumerate through for all implied objects
	for p, node := range root.Index {
		if node.IsObject() {
			keys = append(keys, p)
		}
	}

	sort.Strings(keys)

	buf := new(bytes.Buffer)

	buf.WriteString("// Code generated by ecsgen; DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", b.PackageName))

	for _, k := range keys {
		obj := root.Branch(k)
		code, err := obj.ToGoCode()
		if err != nil {
			return fmt.Errorf("error generating go code for %s: %v", k, err)
		}
		buf.WriteString(code)
	}

	fs := token.NewFileSet()
	astFile, err := parser.ParseFile(fs, "generated_definitions.go", buf.Bytes(), parser.ParseComments)
	if err != nil {
		return fmt.Errorf("error parsing generated go code: %v", err)
	}

	dstBuf := new(bytes.Buffer)
	err = format.Node(dstBuf, fs, astFile)
	if err != nil {
		return fmt.Errorf("error formatting generated go code: %v", err)
	}

	err = ioutil.WriteFile(filepath.Join(b.OutputDir, "generated_definitions.go"), dstBuf.Bytes(), 0644)
	if err != nil {
		return fmt.Errorf("error writing output definitions: %v", err)
	}

	return nil
}
